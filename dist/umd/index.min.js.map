{"version":3,"file":"index.min.js","sources":["../../src/SimplePromiseQueue.ts","../../src/utils.ts","../../src/index.ts","../../src/MockStorage.ts"],"sourcesContent":["// tslint:disable: variable-name\r\nexport default class SimplePromiseQueue {\r\n  private readonly _queue: Array<Promise<void>> = []\r\n  private _flushing = false\r\n\r\n  public enqueue(promise: Promise<void>) {\r\n    this._queue.push(promise)\r\n    if (!this._flushing) { return this.flushQueue() }\r\n    return Promise.resolve()\r\n  }\r\n\r\n  private flushQueue() {\r\n    this._flushing = true\r\n\r\n    const chain = (): Promise<void> | void => {\r\n      const nextTask = this._queue.shift()\r\n      if (nextTask) {\r\n        return nextTask.then(chain)\r\n      } else {\r\n        this._flushing = false\r\n      }\r\n    }\r\n    return Promise.resolve(chain())\r\n  }\r\n}\r\n","import deepmerge from 'deepmerge'\r\n\r\nexport type MergeOptionType = 'replaceArrays' | 'concatArrays'\r\n\r\nconst options: {[k in MergeOptionType]: deepmerge.Options} = {\r\n  replaceArrays: {\r\n    arrayMerge: (destinationArray, sourceArray, options) => sourceArray\r\n  },\r\n  concatArrays: {\r\n    arrayMerge: (target, source, options) => target.concat(...source)\r\n  }\r\n}\r\n\r\nconst defaultMergeOptions: deepmerge.Options = {\r\n  // replacing arrays\r\n  \r\n}\r\n\r\nexport function merge<I, F>(into: Partial<I>, from: Partial<F>, mergeOption: MergeOptionType): I & F & {} {\r\n  return deepmerge(into, from, options[mergeOption])\r\n}\r\n","/**\r\n * Created by championswimmer on 18/07/17.\r\n */\r\nimport { Mutation, MutationPayload, Plugin, Store } from 'vuex'\r\nimport { AsyncStorage } from './AsyncStorage'\r\nimport { MockStorage } from './MockStorage'\r\nimport { PersistOptions } from './PersistOptions'\r\nimport SimplePromiseQueue from './SimplePromiseQueue'\r\nimport { merge, MergeOptionType } from './utils'\r\n\r\nlet FlattedJSON = JSON\r\n\r\n/**\r\n * A class that implements the vuex persistence.\r\n * @type S type of the 'state' inside the store (default: any)\r\n */\r\nexport class VuexPersistence<S> implements PersistOptions<S> {\r\n  public asyncStorage: boolean\r\n  public storage: Storage | AsyncStorage | undefined\r\n  public restoreState: (key: string, storage?: AsyncStorage | Storage) => Promise<S> | S\r\n  public saveState: (key: string, state: {}, storage?: AsyncStorage | Storage) => Promise<void> | void\r\n  public reducer: (state: S) => Partial<S>\r\n  public key: string\r\n  public filter: (mutation: MutationPayload) => boolean\r\n  public modules: string[]\r\n  public strictMode: boolean\r\n  public supportCircular: boolean\r\n  public mergeOption: MergeOptionType\r\n\r\n  /**\r\n   * The plugin function that can be used inside a vuex store.\r\n   */\r\n  public plugin: Plugin<S>\r\n  /**\r\n   * A mutation that can be used to restore state\r\n   * Helpful if we are running in strict mode\r\n   */\r\n  public RESTORE_MUTATION: Mutation<S>\r\n  public subscribed: boolean\r\n\r\n  // tslint:disable-next-line:variable-name\r\n  private _mutex = new SimplePromiseQueue()\r\n\r\n  /**\r\n   * Create a {@link VuexPersistence} object.\r\n   * Use the <code>plugin</code> function of this class as a\r\n   * Vuex plugin.\r\n   * @param {PersistOptions} options\r\n   */\r\n  public constructor(options?: PersistOptions<S>) {\r\n    if (typeof options === 'undefined') options = {} as PersistOptions<S>\r\n    this.key = ((options.key != null) ? options.key : 'vuex')\r\n\r\n    this.subscribed = false\r\n    this.supportCircular = options.supportCircular || false\r\n    if (this.supportCircular) {\r\n      FlattedJSON = require('flatted')\r\n    }\r\n    this.mergeOption = options.mergeOption || 'replaceArrays'\r\n\r\n    let localStorageLitmus = true\r\n\r\n    try {\r\n      window.localStorage.getItem('')\r\n    } catch (err) {\r\n      localStorageLitmus = false\r\n    }\r\n\r\n    /**\r\n     * 1. First, prefer storage sent in optinos\r\n     * 2. Otherwise, use window.localStorage if available\r\n     * 3. Finally, try to use MockStorage\r\n     * 4. None of above? Well we gotta fail.\r\n     */\r\n    if (options.storage) { this.storage = options.storage }\r\n    else if (localStorageLitmus) { this.storage = window.localStorage }\r\n    else if (MockStorage) { this.storage = new MockStorage() }\r\n    else { throw new Error(\"Neither 'window' is defined, nor 'MockStorage' is available\") }\r\n\r\n    /**\r\n     * How this works is -\r\n     *  1. If there is options.reducer function, we use that, if not;\r\n     *  2. We check options.modules;\r\n     *    1. If there is no options.modules array, we use entire state in reducer\r\n     *    2. Otherwise, we create a reducer that merges all those state modules that are\r\n     *        defined in the options.modules[] array\r\n     * @type {((state: S) => {}) | ((state: S) => S) | ((state: any) => {})}\r\n     */\r\n    this.reducer = (\r\n      (options.reducer != null)\r\n        ? options.reducer\r\n        : (\r\n          (options.modules == null)\r\n            ? ((state: S) => state)\r\n            : (\r\n              (state: any) =>\r\n                (options!.modules as string[]).reduce((a, i) =>\r\n                  merge(a, { [i]: state[i] }, this.mergeOption), {/* start empty accumulator*/ })\r\n            )\r\n        )\r\n    )\r\n\r\n    this.filter = options.filter || ((mutation) => true)\r\n\r\n    this.strictMode = options.strictMode || false\r\n\r\n    const _this = this\r\n    this.RESTORE_MUTATION = function RESTORE_MUTATION(state: S, savedState: any) {\r\n      const mergedState = merge(state, savedState || {}, _this.mergeOption)\r\n      for (const propertyName of Object.keys(mergedState as {})) {\r\n        // Maintain support for vue 2\r\n        if ((this as any)._vm !== undefined && (this as any)._vm.$set !== undefined) {\r\n          (this as any)._vm.$set(state, propertyName, (mergedState as any)[propertyName])\r\n          continue\r\n        }\r\n\r\n        (state as any)[propertyName] = (mergedState as any)[propertyName]\r\n      }\r\n    }\r\n\r\n    this.asyncStorage = options.asyncStorage || false\r\n\r\n    if (this.asyncStorage) {\r\n\r\n      /**\r\n       * Async {@link #VuexPersistence.restoreState} implementation\r\n       * @type {((key: string, storage?: Storage) =>\r\n       *      (Promise<S> | S)) | ((key: string, storage: AsyncStorage) => Promise<any>)}\r\n       */\r\n      this.restoreState = (\r\n        (options.restoreState != null)\r\n          ? options.restoreState\r\n          : ((key: string, storage: AsyncStorage) =>\r\n            (storage).getItem(key)\r\n              .then((value) =>\r\n                typeof value === 'string' // If string, parse, or else, just return\r\n                  ? (\r\n                    this.supportCircular\r\n                      ? FlattedJSON.parse(value || '{}')\r\n                      : JSON.parse(value || '{}')\r\n                  )\r\n                  : (value || {})\r\n              )\r\n          )\r\n      )\r\n\r\n      /**\r\n       * Async {@link #VuexPersistence.saveState} implementation\r\n       * @type {((key: string, state: {}, storage?: Storage) =>\r\n       *    (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n       */\r\n      this.saveState = (\r\n        (options.saveState != null)\r\n          ? options.saveState\r\n          : ((key: string, state: {}, storage: AsyncStorage) =>\r\n            (storage).setItem(\r\n              key, // Second argument is state _object_ if asyc storage, stringified otherwise\r\n              // do not stringify the state if the storage type is async\r\n              (this.asyncStorage\r\n                ? merge({}, state || {}, this.mergeOption)\r\n                : (\r\n                  this.supportCircular\r\n                    ? FlattedJSON.stringify(state) as any\r\n                    : JSON.stringify(state) as any\r\n                )\r\n              )\r\n            )\r\n          )\r\n      )\r\n\r\n      /**\r\n       * Async version of plugin\r\n       * @param {Store<S>} store\r\n       */\r\n      this.plugin = (store: Store<S>) => {\r\n        /**\r\n         * For async stores, we're capturing the Promise returned\r\n         * by the `restoreState()` function in a `restored` property\r\n         * on the store itself. This would allow app developers to\r\n         * determine when and if the store's state has indeed been\r\n         * refreshed. This approach was suggested by GitHub user @hotdogee.\r\n         * See https://github.com/championswimmer/vuex-persist/pull/118#issuecomment-500914963\r\n         * @since 2.1.0\r\n         */\r\n        (store as any).restored = ((this.restoreState(this.key, this.storage)) as Promise<S>).then((savedState) => {\r\n          /**\r\n           * If in strict mode, do only via mutation\r\n           */\r\n          if (this.strictMode) {\r\n            store.commit('RESTORE_MUTATION', savedState)\r\n          } else {\r\n            store.replaceState(merge(store.state, savedState || {}, this.mergeOption) as S)\r\n          }\r\n          this.subscriber(store)((mutation: MutationPayload, state: S) => {\r\n            if (this.filter(mutation)) {\r\n              this._mutex.enqueue(\r\n                this.saveState(this.key, this.reducer(state), this.storage) as Promise<void>\r\n              )\r\n            }\r\n          })\r\n          this.subscribed = true\r\n        })\r\n      }\r\n    } else {\r\n\r\n      /**\r\n       * Sync {@link #VuexPersistence.restoreState} implementation\r\n       * @type {((key: string, storage?: Storage) =>\r\n       *    (Promise<S> | S)) | ((key: string, storage: Storage) => (any | string | {}))}\r\n       */\r\n      this.restoreState = (\r\n        (options.restoreState != null)\r\n          ? options.restoreState\r\n          : ((key: string, storage: Storage) => {\r\n            const value = (storage).getItem(key)\r\n            if (typeof value === 'string') {// If string, parse, or else, just return\r\n              return (\r\n                this.supportCircular\r\n                  ? FlattedJSON.parse(value || '{}')\r\n                  : JSON.parse(value || '{}')\r\n              )\r\n            } else {\r\n              return (value || {})\r\n            }\r\n          })\r\n      )\r\n\r\n      /**\r\n       * Sync {@link #VuexPersistence.saveState} implementation\r\n       * @type {((key: string, state: {}, storage?: Storage) =>\r\n       *     (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n       */\r\n      this.saveState = (\r\n        (options.saveState != null)\r\n          ? options.saveState\r\n          : ((key: string, state: {}, storage: Storage) =>\r\n            (storage).setItem(\r\n              key, // Second argument is state _object_ if localforage, stringified otherwise\r\n              (\r\n                this.supportCircular\r\n                  ? FlattedJSON.stringify(state) as any\r\n                  : JSON.stringify(state) as any\r\n              )\r\n            )\r\n          )\r\n      )\r\n\r\n      /**\r\n       * Sync version of plugin\r\n       * @param {Store<S>} store\r\n       */\r\n      this.plugin = (store: Store<S>) => {\r\n        const savedState = this.restoreState(this.key, this.storage) as S\r\n\r\n        if (this.strictMode) {\r\n          store.commit('RESTORE_MUTATION', savedState)\r\n        } else {\r\n          store.replaceState(merge(store.state, savedState || {}, this.mergeOption) as S)\r\n        }\r\n\r\n        this.subscriber(store)((mutation: MutationPayload, state: S) => {\r\n          if (this.filter(mutation)) {\r\n            this.saveState(this.key, this.reducer(state), this.storage)\r\n          }\r\n        })\r\n\r\n        this.subscribed = true\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a subscriber on the store. automatically is used\r\n   * when this is used a vuex plugin. Not for manual usage.\r\n   * @param store\r\n   */\r\n  private subscriber = (store: Store<S>) =>\r\n    (handler: (mutation: MutationPayload, state: S) => any) => store.subscribe(handler)\r\n}\r\n\r\nexport {\r\n  MockStorage, AsyncStorage, PersistOptions\r\n}\r\n\r\nexport default VuexPersistence\r\n","/**\r\n * Created by championswimmer on 22/07/17.\r\n */\r\nlet MockStorage: typeof Storage | undefined\r\n\r\n// @ts-ignore\r\nif (process.env.MODULE_FORMAT !== 'umd') {\r\n  MockStorage = class implements Storage {\r\n    [index: number]: string;\r\n    [key: string]: any;\r\n\r\n    public get length(): number {\r\n      return Object.keys(this).length\r\n    }\r\n\r\n    public key(index: number): string | any {\r\n      return Object.keys(this)[index]\r\n    }\r\n\r\n    public setItem(key: string, data: any): void {\r\n      this[key] = data.toString()\r\n    }\r\n    public getItem(key: string): string {\r\n      return this[key]\r\n    }\r\n    public removeItem(key: string): void {\r\n      delete this[key]\r\n    }\r\n    public clear(): void {\r\n      for (let key of Object.keys(this)) {\r\n        delete this[key]\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport { MockStorage }\r\n"],"names":["SimplePromiseQueue","promise","this","_queue","push","_flushing","Promise","resolve","flushQueue","chain","nextTask","_this","shift","then","options","replaceArrays","arrayMerge","destinationArray","sourceArray","concatArrays","target","source","concat","merge","into","from","mergeOption","deepmerge","localStorageLitmus","store","handler","subscribe","key","subscribed","supportCircular","FlattedJSON","require","window","localStorage","getItem","err","storage","Error","reducer","modules","state","reduce","a","i","_this_1","filter","mutation","strictMode","RESTORE_MUTATION","savedState","mergedState","_a","Object","keys","_i","propertyName","undefined","_vm","$set","asyncStorage","restoreState","value","JSON","parse","saveState","setItem","stringify","plugin","restored","commit","replaceState","subscriber","_mutex","enqueue","MockStorage"],"mappings":"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"}